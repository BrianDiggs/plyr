plyr is a set of tools that solves a common set of problems: you need to break a big problem down into manageable pieces, operate on each pieces and then put all the pieces back together.  It's already possible to do this with split and the apply functions, but plyr just makes it all a bit easier with:

  * consistent names, arguments and outputs
  * input from and output to data.frames, matrices and lists
  * progress bars to keep track of long running operations
  * built-in error recovery 
  * the choice of passing chunks as rows or as variables
  
plyr functions are named according to the type of object they input (first letter) and output (second letter):

  * llply = from a list to a list
  * alply = from an array to a list
  * ldply = from a list to a data.frame
  * d_ply = from a data.frame, ignore output
  * and so on for llply, laply, ldply, l_ply, alply, aaply, adply, a_ply, dlply, daply, dply, d_ply

This avoids any ambiguity about what you'll get back from one of these functions.  


  * aggregate(mtcars, list(mtcars$cyl), median) 
    daply(mtcars, .(cyl), colwise(median))
    daply(mtcars, .(cyl), colwise(median, .if = is.numeric))
    
  * p <- function(df) coef(lm(mpg ~ wt, data = df))
    do.call("rbind", lapply(split(mtcars, mtcars$cyl), p))
    ddply(mtcars, .(cyl), p)

The aim of this releases is to provide a consistent and useful set of tools for solving the split-apply-combine problem.  It is not particularly fast or memory efficient, but there is much potential for optimisation, particularly by rewriting important bits in C.